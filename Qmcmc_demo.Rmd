---
title: "Qmcmc_demo"
output: html_document
date: "2024-11-25"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}

library(Matrix)  # 用于矩阵操作
library(dplyr)   # 数据处理
library(tibble)  # 数据表格式
library(pracma)

# 初始化量子态
initialize_state <- function(n_spins, bitstring) {
  if (length(bitstring) != n_spins) {
    stop("Bitstring length must match the number of spins!")
  }
  state <- rep(0, 2^n_spins)
  index <- sum(bitstring * 2^((n_spins-1):0)) + 1
  state[index] <- 1
  return(state)
}

# 生成哈密顿量矩阵
generate_hamiltonian <- function(n_spins, h, J) {
  size <- 2^n_spins  # 哈密顿量的维度
  H <- matrix(0, nrow = size, ncol = size)  # 初始化哈密顿量为零矩阵
  
  # 单比特 Z 项
  for (i in 1:n_spins) {
    # 构造 Z_i 矩阵
    Z_i <- diag(rep(c(rep(1, 2^(n_spins-i)), rep(-1, 2^(n_spins-i))), 2^(i-1)))
    Z_i <- as.matrix(as.numeric(Z_i))  # 确保是数值型矩阵
    H <- H + h[i] * Z_i
  }
  
  # 双比特 ZZ 项
  for (i in 1:(n_spins-1)) {
    for (j in (i+1):n_spins) {
      # 构造 Z_i 和 Z_j
      Z_i <- diag(rep(c(rep(1, 2^(n_spins-i)), rep(-1, 2^(n_spins-i))), 2^(i-1)))
      Z_j <- diag(rep(c(rep(1, 2^(n_spins-j)), rep(-1, 2^(n_spins-j))), 2^(j-1)))
      Z_i <- as.matrix(as.numeric(Z_i))  # 确保是数值型矩阵
      Z_j <- as.matrix(as.numeric(Z_j))  # 确保是数值型矩阵
      H <- H + J[i, j] * (Z_i %*% Z_j)
    }
  }
  return(H)
}

# 时间演化（通过矩阵指数计算）
time_evolution <- function(state, hamiltonian, delta_t) {
  # 时间演化算符
  U <- expm(-1i * delta_t * hamiltonian)  # 确保 hamiltonian 是数值型矩阵
  
  # 演化后的量子态
  return(U %*% state)
}

# 随机采样状态
sample_state <- function(state) {
  probs <- abs(state)^2
  sampled_index <- sample(1:length(probs), size = 1, prob = probs)
  binary_state <- intToBits(sampled_index - 1)[1:log2(length(state))]
  return(rev(as.numeric(binary_state)))
}

# QMCMC 主过程
qmcmc <- function(
  n_spins, n_hops, h, J, initial_state, delta_t, temperature
) {
  # 初始化状态
  state <- initialize_state(n_spins, initial_state)
  
  # 构造哈密顿量
  H <- generate_hamiltonian(n_spins, h, J)
  
  # 验证哈密顿量是否为数值矩阵
  if (!is.matrix(H) || typeof(H) != "double") {
    stop("Hamiltonian matrix must be numeric and square.")
  }
  
  # 保存采样结果
  results <- list()
  
  for (i in 1:n_hops) {
    # 量子时间演化
    evolved_state <- time_evolution(state, H, delta_t)
    
    # 随机采样
    new_state <- sample_state(evolved_state)
    
    # 能量差计算
    energy_current <- Re(Conj(t(state)) %*% H %*% state)
    energy_new <- Re(Conj(t(new_state)) %*% H %*% new_state)
    
    # 接受概率
    accept_prob <- min(1, exp((energy_current - energy_new) / temperature))
    if (runif(1) < accept_prob) {
      state <- new_state
    }
    
    # 保存状态
    results[[i]] <- list(
      iteration = i,
      state = state,
      energy = Re(Conj(t(state)) %*% H %*% state)
    )
  }
  
  return(results)
}


```



```{r}

# 示例使用
n_spins <- 3
n_hops <- 10
h <- c(0.5, -0.5, 0.3)  # 单比特 Z 项的系数
J <- matrix(c(0, 0.1, 0.2, 0.1, 0, 0.3, 0.2, 0.3, 0), nrow = 3)  # 双比特 ZZ 项的系数
initial_state <- c(1, 0, 0)  # 初始比特串
delta_t <- 0.8
temperature <- 1

results <- qmcmc(n_spins, n_hops, h, J, initial_state, delta_t, temperature)

# 打印结果
for (result in results) {
  cat("Iteration:", result$iteration, 
      "State:", paste(result$state, collapse = ""), 
      "Energy:", result$energy, "\n")
}


```

